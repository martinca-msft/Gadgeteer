// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache v.2 license.
namespace Gadgeteer
{
    using Microsoft.SPOT;
    using System.Collections;
    using System;
    using System.Threading;
    /// <summary>
    /// Provides a timer to enable periodic status checks or actions, or a one-off stopwatch.
    /// </summary>
    /// <remarks>
    /// This class ensures the event occures on Gadgeteer's application thread.
    /// </remarks>
    public class Timer
    {
        private System.Threading.Timer dt;
        private static Hashtable activeTimers = new Hashtable();
        private object instanceLock = new object();

        private TimeSpan interval;
        private ThreadStart dispatcherTick;

        // Note: A constructor summary is auto-generated by the doc builder.
        /// <summary></summary>
        /// <param name="interval">The interval for the timer.</param>
        public Timer(TimeSpan interval)
            : this(interval, BehaviorType.RunContinuously) { }

        // Note: A constructor summary is auto-generated by the doc builder.
        /// <summary></summary>
        /// <param name="intervalMilliseconds">The interval for the timer.</param>
        public Timer(int intervalMilliseconds)
            : this(new TimeSpan(0, 0, 0, 0, intervalMilliseconds), BehaviorType.RunContinuously) { }

        // Note: A constructor summary is auto-generated by the doc builder.
        /// <summary></summary>
        /// <param name="interval">The interval for the timer.</param>
        /// <param name="behavior">The behavior for the timer (run once or continuously).</param>
        public Timer(TimeSpan interval, BehaviorType behavior)
        {
            if (Program.Dispatcher == null)
            {
                Debug.Print("WARN: null Program.Dispatcher in GT.Timer constructor");
            }

            this.interval = interval;
            this.dispatcherTick = new ThreadStart(dt_Tick);
            this.dt = new System.Threading.Timer(Callback, null, Timeout.Infinite, Timeout.Infinite);
            this.behavior = behavior;
        }

        // Note: A constructor summary is auto-generated by the doc builder.
        /// <summary></summary>
        /// <param name="intervalMilliseconds">The interval for the timer.</param>
        /// <param name="behavior">The behavior for the timer (run once or continuously).</param>
        public Timer(int intervalMilliseconds, BehaviorType behavior)
            : this(new TimeSpan(0, 0, 0, 0, intervalMilliseconds), behavior) { }


        private BehaviorType behavior;
        /// <summary>
        ///  The behavior of this timer - whether to run once or run continuously.
        /// </summary>
        public BehaviorType Behavior { get { return this.behavior; } set { this.behavior = value; } }

        /// <summary>
        /// An enumeration of timer behaviours
        /// </summary>
        public enum BehaviorType
        {
            /// <summary>
            /// Run once when started, and then stop, so a single Tick event is generated.
            /// </summary>
            RunOnce,
            /// <summary>
            /// Run continually after being started, so Tick events are generated periodically.
            /// </summary>
            RunContinuously
        }

        void Callback(object state)
        {
            Program.Dispatcher.BeginInvoke(this.dispatcherTick);
        }

        void dt_Tick()
        {
            try
            {
                if (this.behavior == BehaviorType.RunOnce) Stop();
                if (Tick != null) Tick(this);
            }
            catch 
            {
                Debug.Print("Exception performing Timer operation");
            }
        }

        /// <summary>
        /// Starts the dispatch timer.
        /// </summary>
        /// <remarks>
        /// When you create a <see cref="Timer"/> object, by default it is not started
        /// (that is, <see cref="IsRunning"/> is <b>false</b>). When you want to use the timer,
        /// you must first call this method.
        /// </remarks>
        public void Start()
        {
            lock (instanceLock)
            {
                if (!activeTimers.Contains(this))
                {
                    activeTimers.Add(this, null);
                    //Debug.Print("Added reference to active timer with interval " + Interval);
                }
                this.dt.Change(this.interval, this.interval);
            }
        }

        /// <summary>
        /// Stops the dispatch timer.
        /// </summary>
        public void Stop()
        {
            lock (instanceLock)
            {
                if (activeTimers.Contains(this))
                {
                    activeTimers.Remove(this);
                    //Debug.Print("Removed reference to inactive timer with interval " + Interval);
                }
                this.dt.Change(Timeout.Infinite, Timeout.Infinite);
            }
        }

        /// <summary>
        /// Restarts the timer
        /// </summary>
        public void Restart()
        {
            this.dt.Change(Timeout.Infinite, Timeout.Infinite);
            Start();
        }

        /// <summary>
        /// Gets a value that indicates whether this timer is running.
        /// </summary>
        public bool IsRunning { get { return activeTimers.Contains(this); } }

        /// <summary>
        /// Gets the interval that was assigned to this timer.
        /// </summary>
        public TimeSpan Interval
        {
            get { return this.interval; }
            set
            {
                bool updateTimer = false;
                long ticks = value.Ticks;

                if (ticks < 0)
                    throw new ArgumentOutOfRangeException("value", "too small");

                if (ticks > Int32.MaxValue * TimeSpan.TicksPerMillisecond)
                    throw new ArgumentOutOfRangeException("value", "too large");

                lock (instanceLock)
                {
                    this.interval = value;

                    if (IsRunning)
                        updateTimer = true;
                }

                if (updateTimer)
                    this.dt.Change(value, value);
            }
        }

        /// <summary>
        /// Represents the delegate that is used for the <see cref="Tick"/> event.
        /// </summary>
        /// <param name="timer">The timer associated with the tick.</param>
        public delegate void TickEventHandler(Timer timer);

        /// <summary>
        /// Raised after each timer interval specified by <see cref="Interval"/>.
        /// </summary>
        /// <remarks>
        /// This event is raised when the timer is running, that is <see cref="IsRunning"/> is <b>true</b>.
        /// Handle this event to perform periodic actions.
        /// </remarks>
        public event TickEventHandler Tick;

        /// <summary>
        /// Gets a hash code for this object
        /// </summary>
        /// <returns>The hash code</returns>
        public override int GetHashCode()
        {
            return this.dt.GetHashCode();
        }

        /// <summary>
        /// Gets the hardware uptime, i.e. the time interval since the hardware was powered on.
        /// </summary>
        /// <returns>The hardware uptime.</returns>
        public static TimeSpan GetMachineTime()
        {
            return Microsoft.SPOT.Hardware.Utility.GetMachineTime();
        }
    }
}
